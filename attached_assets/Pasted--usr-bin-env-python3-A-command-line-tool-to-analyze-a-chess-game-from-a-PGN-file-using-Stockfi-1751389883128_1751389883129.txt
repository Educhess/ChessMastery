#!/usr/bin/env python3
"""
A command-line tool to analyze a chess game from a PGN file using Stockfish.

This script reads a PGN from standard input, analyzes each move to find
evaluation changes, and prints a summary of the analysis, highlighting
significant blunders.

Usage:
  cat my_game.pgn | python3 this_script.py
  cat my_game.pgn | python3 this_script.py --mode fast
"""

import argparse
import sys
from io import StringIO
import chess.pgn
import chess.engine

# === CONFIGURATION ===
# Assumes 'stockfish' is in your system's PATH.
# You can change this to the full path of your Stockfish executable.
STOCKFISH_PATH = "stockfish"


def _get_eval_in_pawns(score_pov):
    """
    Converts a chess.engine.PovScore object to a float pawn value.

    Clamps mate scores to +/- 100.0 for simplicity.
    """
    if score_pov.is_mate():
        # Positive mate score for the side to move, negative if they are getting mated.
        mate_in = score_pov.mate()
        return 100.0 if mate_in > 0 else -100.0
    else:
        # The score is from the perspective of the side to move.
        # Convert centipawns to pawns.
        return score_pov.score() / 100.0


def analyze_game_from_pgn(pgn_content, analysis_mode="accurate"):
    """
    Analyzes a chess game from PGN content using Stockfish.

    Args:
        pgn_content (str): The PGN string of the game.
        analysis_mode (str): 'fast' (depth-based) or 'accurate' (time-based).

    Returns:
        dict: A dictionary containing the analysis results or an error message.
    """
    try:
        pgn_io = StringIO(pgn_content)
        game = chess.pgn.read_game(pgn_io)
        if not game:
            return {"error": "Failed to parse PGN content. Please provide a valid PGN."}

        if analysis_mode == "fast":
            limit = chess.engine.Limit(depth=12)
        else:
            limit = chess.engine.Limit(time=0.5)

        # The engine is created and closed for each game, ensuring a clean state.
        with chess.engine.SimpleEngine.popen_uci(STOCKFISH_PATH) as engine:
            board = game.board()
            node = game
            moves_analysis = []
            big_drops = []
            max_moves = 80  # A reasonable limit to prevent timeouts on very long games.

            headers = game.headers
            game_info = {
                "event": headers.get("Event", "PGN Game"),
                "white": headers.get("White", "?"),
                "black": headers.get("Black", "?"),
                "result": headers.get("Result", "*"),
            }

            for move_count, next_node in enumerate(node.mainline(), 1):
                if move_count > max_moves:
                    break
                
                played_move = next_node.move

                # === 1. Evaluate BEFORE the move ===
                # The score is from the perspective of the player about to move.
                info_before = engine.analyse(board, limit)
                score_before = _get_eval_in_pawns(info_before["score"].relative)
                best_move = info_before.get("pv", [None])[0]

                try:
                    san_played = board.san(played_move)
                except chess.IllegalMoveError:
                    san_played = "illegal" # Handle illegal moves gracefully
                except Exception:
                    san_played = board.uci(played_move)
                
                san_best = board.san(best_move) if best_move else "N/A"

                # Apply the move to the board
                board.push(played_move)

                # === 2. Evaluate AFTER the move ===
                # The score is now from the perspective of the OPPONENT.
                info_after = engine.analyse(board, limit)
                score_after_opponent_pov = _get_eval_in_pawns(info_after["score"].relative)

                # *** CRITICAL FIX ***
                # To compare, we must flip the opponent's score back to the
                # original player's perspective.
                score_after_player_pov = -score_after_opponent_pov

                # The evaluation drop is the difference from the original player's perspective.
                # A positive drop indicates a blunder.
                eval_drop = score_before - score_after_player_pov

                # Store move-by-move analysis
                moves_analysis.append({
                    "move_number": board.fullmove_number if board.turn == chess.BLACK else f"{board.fullmove_number-1}...",
                    "san": san_played,
                    "eval_before": score_before,
                    "eval_after": score_after_player_pov, # Use the corrected perspective
                    "best_move": san_best,
                })

                # Track significant drops (blunders)
                if eval_drop >= 2.0 and played_move != best_move:
                    big_drops.append({
                        "move_number": board.fullmove_number if board.turn == chess.BLACK else f"{board.fullmove_number-1}...",
                        "played": san_played,
                        "best": san_best,
                        "eval_before": score_before,
                        "eval_after": score_after_player_pov,
                        "delta": eval_drop,
                    })

            return {
                "game_info": game_info,
                "moves_analysis": moves_analysis,
                "big_drops": big_drops,
            }

    except Exception as e:
        # Catch potential engine errors or other exceptions
        return {"error": f"An unexpected error occurred: {e}"}


def format_analysis_output(analysis, pgn_filename="game.pgn"):
    """
    Formats the analysis dictionary into a human-readable string.
    """
    if "error" in analysis:
        return f"Error: {analysis['error']}"

    output = []
    game_info = analysis["game_info"]
    game_title = game_info.get("event") if game_info.get("event") != "?" else pgn_filename
    output.append(f"📂 Game: {game_title} ({game_info['white']} vs. {game_info['black']})")
    output.append("-" * 40)

    # Move-by-move analysis
    for move in analysis["moves_analysis"]:
        # Simplified f-string formatting works for positive and negative floats.
        eval_before_str = f"{move['eval_before']:>5.2f}"
        eval_after_str = f"{move['eval_after']:>5.2f}"
        move_line = f"Move {str(move['move_number']):<5s}: {move['san']:<7s} | Eval: {eval_before_str} → {eval_after_str}"
        output.append(move_line)

    output.append("")

    # Significant drops summary
    if analysis["big_drops"]:
        output.append("⚠️  Significant Evaluation Drops (Blunders):")
        for drop in analysis["big_drops"]:
            drop_line = (
                f"  Move {str(drop['move_number']):<5s}: Played {drop['played']}, but best was {drop['best']}. "
                f"Eval dropped from {drop['eval_before']:.2f} to {drop['eval_after']:.2f} (Δ = {drop['delta']:.2f})"
            )
            output.append(drop_line)
    else:
        output.append("✅ No major blunders detected.")

    return "\n".join(output)


def main():
    """Main function to handle command-line arguments and script execution."""
    parser = argparse.ArgumentParser(description="Analyze a chess game from PGN.")
    parser.add_argument(
        "--mode",
        choices=["fast", "accurate"],
        default="accurate",
        help="Choose analysis mode: 'fast' (depth 12) or 'accurate' (time 0.5s/move).",
    )
    args = parser.parse_args()

    # Print informational messages to stderr to not interfere with stdout.
    if args.mode == "fast":
        print("⚡ Fast mode (depth 12)", file=sys.stderr)
    else:
        print("🔍 Accurate mode (time=0.5s)", file=sys.stderr)

    pgn_content = sys.stdin.read().strip()
    if not pgn_content:
        print("Error: No PGN content provided to standard input.", file=sys.stderr)
        sys.exit(1)

    analysis = analyze_game_from_pgn(pgn_content, args.mode)
    print(format_analysis_output(analysis))


if __name__ == "__main__":
    main()