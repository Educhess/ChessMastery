#!/usr/bin/env python3
"""
A command-line tool to analyze a chess game from a PGN file using Stockfish.

This script reads a PGN from standard input and uses a timed analysis
model, letting the engine think for a set amount of time on each move.
It uses the engine's internal time management for robustness, avoiding timeouts.

Usage:
  cat my_game.pgn | python3 this_script.py
  cat my_game.pgn | python3 this_script.py --think-time 3
"""

import argparse
import sys
from io import StringIO
import chess.pgn
import chess.engine

# === CONFIGURATION ===
STOCKFISH_PATH = "stockfish"

def _get_eval_in_pawns(score_pov):
    """Converts a chess.engine.PovScore to a float pawn value, clamping mates."""
    if score_pov.is_mate():
        mate_in = score_pov.mate()
        # A large but not infinite number to represent a forced mate.
        return 100.0 if mate_in > 0 else -100.0
    else:
        # Use mate_score to handle cases where the engine sees a mate but PovScore is not yet a mate object
        return score_pov.score(mate_score=10000) / 100.0

def _get_timed_analysis(engine, board, think_time):
    """
    Analyzes a board position for a fixed amount of time.

    This function delegates time management to the engine itself, which is
    the most reliable way to perform timed analysis.

    Args:
        engine: The chess.engine.SimpleEngine instance.
        board: The chess.Board to analyze.
        think_time (float): The number of seconds to analyze the position.

    Returns:
        tuple: (final_score, best_move_found)
    """
    # Create a time-based limit for the engine.
    limit = chess.engine.Limit(time=think_time)
    last_info = None

    # The `engine.analysis` context will automatically end when the engine
    # finishes its search (after `think_time` seconds).
    with engine.analysis(board, limit) as analysis:
        for info in analysis:
            # Keep storing the latest information object. The last one received
            # before the time limit is reached will be the most accurate.
            last_info = info
            
            # Optional: Print live updates to stderr for user feedback
            if "depth" in info and "score" in info:
                score = _get_eval_in_pawns(info["score"].relative)
                # Use carriage return to print on the same line, overwriting previous updates
                print(f"  ... thinking, depth: {info['depth']:<2}, eval: {score:+.2f}", end='\r', file=sys.stderr)
    
    # Clear the "thinking" line from stderr
    print(" " * 60, end='\r', file=sys.stderr)

    if last_info:
        final_score = _get_eval_in_pawns(last_info["score"].relative)
        best_move = last_info.get("pv", [None])[0]
        return final_score, best_move
    else:
        # This is a fallback in case no analysis info was returned
        return 0.0, None


def analyze_game_from_pgn(pgn_content, think_time=2.0):
    """Analyzes a chess game from PGN content using timed Stockfish analysis."""
    try:
        pgn_io = StringIO(pgn_content)
        game = chess.pgn.read_game(pgn_io)
        if not game:
            return {"error": "Failed to parse PGN content. Please provide a valid PGN."}

        with chess.engine.SimpleEngine.popen_uci(STOCKFISH_PATH) as engine:
            board = game.board()
            moves_analysis = []
            big_drops = []
            
            headers = game.headers
            game_info = {
                "event": headers.get("Event", "PGN Game"),
                "white": headers.get("White", "?"),
                "black": headers.get("Black", "?"),
            }

            for next_node in game.mainline():
                move_num_str = f"{board.fullmove_number}{'.' if board.turn == chess.WHITE else '...'}"
                print(f"Analyzing move {move_num_str} {board.san(next_node.move)}...", file=sys.stderr)

                # === 1. Evaluate BEFORE the move ===
                score_before, best_move_before = _get_timed_analysis(engine, board, think_time)
                
                san_played = board.san(next_node.move)
                san_best = board.san(best_move_before) if best_move_before else "N/A"

                # Apply the move
                board.push(next_node.move)

                # === 2. Evaluate AFTER the move ===
                score_after_opponent_pov, _ = _get_timed_analysis(engine, board, think_time)
                
                # Flip the score back to the original player's perspective for comparison
                score_after_player_pov = -score_after_opponent_pov
                eval_drop = score_before - score_after_player_pov
                
                # Determine move number string for output
                is_white_move = board.turn == chess.BLACK
                move_number_display = board.fullmove_number if is_white_move else f"{board.fullmove_number-1}..."
                
                moves_analysis.append({
                    "move_number": move_number_display,
                    "san": san_played,
                    "eval_before": score_before,
                    "eval_after": score_after_player_pov,
                })
                
                # Track significant drops
                if eval_drop >= 2.0 and next_node.move != best_move_before:
                    big_drops.append({
                        "move_number": move_number_display,
                        "played": san_played,
                        "best": san_best,
                        "eval_before": score_before,
                        "eval_after": score_after_player_pov,
                        "delta": eval_drop,
                    })

            return {
                "game_info": game_info,
                "moves_analysis": moves_analysis,
                "big_drops": big_drops,
            }

    except chess.engine.EngineTerminatedError:
        return {"error": "Stockfish engine terminated unexpectedly. Is it installed correctly?"}
    except Exception as e:
        return {"error": f"An unexpected error occurred: {e}"}

# The `format_analysis_output` and `main` functions remain the same as the previous version.
# They are included here for completeness.

def format_analysis_output(analysis, pgn_filename="game.pgn"):
    """Formats the analysis dictionary into a human-readable string."""
    if "error" in analysis:
        return f"Error: {analysis['error']}"

    output = []
    game_info = analysis["game_info"]
    game_title = game_info.get("event") if game_info.get("event") != "?" else pgn_filename
    output.append(f"📂 Game: {game_title} ({game_info['white']} vs. {game_info['black']})")
    output.append("-" * 40)

    for move in analysis["moves_analysis"]:
        eval_before_str = f"{move['eval_before']:>5.2f}"
        eval_after_str = f"{move['eval_after']:>5.2f}"
        move_line = f"Move {str(move['move_number']):<5s}: {move['san']:<7s} | Eval: {eval_before_str} → {eval_after_str}"
        output.append(move_line)

    output.append("")

    if analysis["big_drops"]:
        output.append("⚠️  Significant Evaluation Drops (Blunders):")
        for drop in analysis["big_drops"]:
            drop_line = (
                f"  Move {str(drop['move_number']):<5s}: Played {drop['played']}, but best was {drop['best']}. "
                f"Eval dropped from {drop['eval_before']:.2f} to {drop['eval_after']:.2f} (Δ = {drop['delta']:.2f})"
            )
            output.append(drop_line)
    else:
        output.append("✅ No major blunders detected.")

    return "\n".join(output)


def main():
    """Main function to handle command-line arguments and script execution."""
    parser = argparse.ArgumentParser(description="Analyze a chess game from PGN using timed analysis.")
    parser.add_argument(
        "--think-time",
        type=float,
        default=1.0, # Reduced default for faster runs, can be increased
        help="Seconds to let the engine think on each half-move (default: 1.0).",
    )
    args = parser.parse_args()

    print(f"🔍 Timed analysis mode ({args.think_time}s per move)", file=sys.stderr)

    pgn_content = sys.stdin.read().strip()
    if not pgn_content:
        print("Error: No PGN content provided to standard input.", file=sys.stderr)
        sys.exit(1)

    analysis = analyze_game_from_pgn(pgn_content, args.think_time)
    print("\n" + "="*40 + "\nANALYSIS COMPLETE\n" + "="*40, file=sys.stderr)
    print(format_analysis_output(analysis))


if __name__ == "__main__":
    main()